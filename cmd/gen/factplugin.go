package gen

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

func FactPlugin(plugins []string, pkg string) {
	log.Printf("Generating fact plugin funcs for package %s: %s\n", pkg, strings.Join(plugins, ","))

	importLine := "import \"github.com/salsadigitalauorg/shipshape/pkg/fact\"\n\n"

	for _, p := range plugins {
		pluginFile := strings.ToLower(p) + "_gen.go"
		pluginDir := filepath.Join(getScriptPath(), "..", "..", "pkg", "fact")
		if pkg != "fact" {
			pluginDir = filepath.Join(pluginDir, pkg)
		}
		pluginFullFilePath := filepath.Join(pluginDir, pluginFile)
		if err := os.Remove(pluginFullFilePath); err != nil && !os.IsNotExist(err) {
			log.Fatalln(err)
		}
		createFile(pluginFullFilePath, fmt.Sprintf("package %s\n\n", pkg))
		appendFileContent(pluginFullFilePath, importLine)
		appendFileContent(pluginFullFilePath, fmt.Sprintf(
			"// Code generated by fact-plugin --plugin=%s --package=%s; "+
				"DO NOT EDIT.\n", p, pkg))
		appendFileContent(pluginFullFilePath, factPluginFuncs(p))
	}
}

func factPluginFuncs(fp string) string {
	tmplStr := `
func (p *{{.Plugin}}) GetName() string {
	return p.Name
}

func (p *{{.Plugin}}) GetFormat() fact.FactFormat {
	return p.Format
}

func (p *{{.Plugin}}) GetConnection() string {
	return p.Connection
}

func (p *{{.Plugin}}) GetErrors() []error {
	return p.errors
}
`
	tmpl, err := template.New("factPluginFuncs").Parse(tmplStr)
	if err != nil {
		log.Fatalln(err)
	}

	buf := &bytes.Buffer{}
	err = tmpl.Execute(buf, struct{ Plugin string }{fp})
	if err != nil {
		log.Fatalln(err)
	}
	return buf.String()
}
