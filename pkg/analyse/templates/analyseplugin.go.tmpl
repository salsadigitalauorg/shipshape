package analyse

import (
	log "github.com/sirupsen/logrus"

	"github.com/salsadigitalauorg/shipshape/pkg/breach"
	"github.com/salsadigitalauorg/shipshape/pkg/fact"
	"github.com/salsadigitalauorg/shipshape/pkg/result"
)

// Code generated by analyse-plugin --plugin={{ .Plugin }}; DO NOT EDIT.

func New{{ .Plugin }}(id string) *{{ .Plugin }} {
	return &{{ .Plugin }}{
		Id: id,
		Result: result.Result{Name: id, Severity: "normal"},
	}
}

func (p *{{ .Plugin }}) SetInput(input fact.Facter) {
	p.input = input
}

func (p *{{ .Plugin }}) GetId() string {
	return p.Id
}

func (p *{{ .Plugin }}) GetDescription() string {
	return p.Description
}

func (p *{{ .Plugin }}) GetInputName() string {
	return p.InputName
}

func (p *{{ .Plugin }}) GetBreachTemplate() breach.BreachTemplate {
	return p.BreachTemplate
}

func (p *{{ .Plugin }}) GetResult() result.Result {
	if p.Description != "" && p.Result.Name != p.Description {
		p.Result.Name = p.Description
	}
	return p.Result
}

func (p *{{ .Plugin }}) ValidateInput() error {
	log.WithFields(log.Fields{
		"analyser": p.Id,
	}).Debug("validating input")

	plugin := fact.GetInstance(p.InputName)
	if plugin == nil {
		return &fact.ErrSupportNotFound{
			Plugin: p.GetId(), SupportType: "input", SupportPlugin: p.InputName}
	}

	p.input = plugin
	return nil
}

func (p *{{ .Plugin }}) PreProcessInput() bool {
	if p.input == nil {
		p.AddBreach(&breach.ValueBreach{
			Value: "no input available to analyse",
		})
		return false
	}

	if len(p.input.GetErrors()) > 0 {
		errs := []string{}
		for _, e := range p.input.GetErrors() {
			errs = append(errs, e.Error())
		}
		p.AddBreach(&breach.KeyValuesBreach{
			Key: "input failure",
			Values:      errs,
		})
		return false
	}

	return true
}

// AddBreach appends a Breach to the Result.
func (p *{{ .Plugin }}) AddBreach(b breach.Breach) {
	b.SetCommonValues("", p.Id, p.Severity)
	p.Result.Breaches = append(
		p.Result.Breaches,
		b,
	)
}
