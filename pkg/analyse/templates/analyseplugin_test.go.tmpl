package analyse_test

import (
	"errors"
	"testing"

	"github.com/stretchr/testify/assert"

	. "github.com/salsadigitalauorg/shipshape/pkg/analyse"
	"github.com/salsadigitalauorg/shipshape/pkg/breach"
	"github.com/salsadigitalauorg/shipshape/pkg/data"
	"github.com/salsadigitalauorg/shipshape/pkg/fact"
	"github.com/salsadigitalauorg/shipshape/pkg/fact/testdata"
	"github.com/salsadigitalauorg/shipshape/pkg/result"
)

// Code generated by analyse-plugin --plugin={{ .Plugin }}; DO NOT EDIT.
// The proper way to update this file is to
//   - modify one of the pkg/analyse/*_gen_test.go files as needed,
//   - copy the changes to pkg/analyse/templates/analyseplugin_test.go.tmpl,
//   - replace the plugin struct name with {{ .Plugin }} wherever needed.

func Test{{ .Plugin }}Getters(t *testing.T) {
	instance := {{ .Plugin }}{
		Id:          "test{{ .Plugin }}",
		Description: "description of the test {{ .Plugin }} analyser",
		InputName:   "testInputName",
	}
	assert.Equal(t, "test{{ .Plugin }}", instance.GetId())
	assert.Equal(t, "description of the test {{ .Plugin }} analyser", instance.GetDescription())
	assert.Equal(t, "testInputName", instance.GetInputName())
}

func Test{{ .Plugin }}GetResult(t *testing.T) {
	t.Run("noDescription", func(t *testing.T) {
		instance := {{ .Plugin }}{
			Result: result.Result{Name: "test{{ .Plugin }}ResultName"},
		}
		assert.Equal(t, "test{{ .Plugin }}ResultName", instance.GetResult().Name)
	})

	t.Run("description", func(t *testing.T) {
		instance := {{ .Plugin }}{
			Result:      result.Result{Name: "test{{ .Plugin }}ResultName"},
			Description: "description of the test {{ .Plugin }} analyser",
		}
		assert.Equal(t, "description of the test {{ .Plugin }} analyser", instance.GetResult().Name)
	})
}

func Test{{ .Plugin }}ValidateInput(t *testing.T) {
	t.Run("noInput", func(t *testing.T) {
		instance := {{ .Plugin }}{}
		err := instance.ValidateInput()
		assert.Equal(t, &fact.ErrSupportNotFound{
			Plugin: "", SupportType: "input", SupportPlugin: ""}, err)
	})

	t.Run("input", func(t *testing.T) {
		origFacts := fact.Facts
		defer func() { fact.Facts = origFacts }()

		testFacter := &testdata.TestFacter{
			Name:                "testFacter",
			TestInputDataFormat: data.FormatListString,
			TestInputData:       nil,
		}

		fact.Facts = map[string]fact.Facter{"testInputName": testFacter}
		instance := {{ .Plugin }}{InputName: "testInputName"}
		instance.SetInput(testFacter)
		err := instance.ValidateInput()
		assert.Nil(t, err)
	})
}

func Test{{ .Plugin }}PreProcessInput(t *testing.T) {
	t.Run("noInput", func(t *testing.T) {
		instance := {{ .Plugin }}{}
		assert.False(t, instance.PreProcessInput())
		assert.ElementsMatch(t, []breach.Breach{&breach.ValueBreach{
			BreachType: "value",
			Value: "no input available to analyse"}}, instance.GetResult().Breaches)
	})

	t.Run("inputNoError", func(t *testing.T) {
		instance := {{ .Plugin }}{}
		instance.SetInput(&testdata.TestFacter{Name: "testFacter"})
		assert.True(t, instance.PreProcessInput())
	})

	t.Run("inputWithError", func(t *testing.T) {
		instance := {{ .Plugin }}{}
		testInput := testdata.TestFacter{Name: "testFacter"}
		testInput.AddError(errors.New("test error"))
		instance.SetInput(&testInput)
		assert.False(t, instance.PreProcessInput())
		assert.ElementsMatch(t, []breach.Breach{&breach.KeyValuesBreach{
			BreachType: "key-values",
			Key: "input failure",
			Values: []string{"test error"}}}, instance.GetResult().Breaches)
	})
}
